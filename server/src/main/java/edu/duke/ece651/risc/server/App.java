/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package edu.duke.ece651.risc.server;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintStream;
import java.io.PrintWriter;
import java.net.ServerSocket;
import java.net.Socket;
import java.util.*;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;



import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.mongodb.BasicDBObject;
import com.mongodb.MongoClient;
import com.mongodb.client.FindIterable;
import com.mongodb.client.MongoCollection;
import com.mongodb.client.MongoCursor;
import com.mongodb.client.MongoDatabase;
import com.mongodb.client.model.Filters;
import com.mongodb.connection.Server;

import org.bson.Document;
import org.slf4j.LoggerFactory;

import ch.qos.logback.classic.Level;
import ch.qos.logback.classic.LoggerContext;
import edu.duke.ece651.risc.shared.*;
import edu.duke.ece651.risc.shared.game.*;


public class App {
  public volatile ArrayList<Game> games;
  private final ServerSocket hostSocket;
  private final PrintStream output;
  private volatile Map<String, ServerPlayer> players;
  private Map<String, actionHandler> actionHandlerMap;
  private ExecutorService threadPool;

  public volatile MongoClient mongoClient;
  public volatile MongoDatabase mongoDatabase;
  public volatile MongoCollection<Document> playersCollection;// only need players names
  public volatile MongoCollection<Document> gamesCollection;
  private JSONSerializer serializer;

  /**
   * the constructor of App build the socket based on the port number initialize
   * the games list
   */
  public App(ServerSocket s, PrintStream out) {
    games = new ArrayList<>();
    this.output = out;
    this.hostSocket = s;
    this.players = new HashMap<>();
    this.actionHandlerMap = new HashMap<>();
    this.threadPool = Executors.newFixedThreadPool(10);
    actionHandlerMap.put(Constant.GET_GAMELIST, this::sendGameList);
    actionHandlerMap.put(Constant.STARTGAME, this::startNewGame);
    actionHandlerMap.put(Constant.JOINGAME, this::joinAndRun);
    actionHandlerMap.put(Constant.REJOINGAME, this::rejoinGame);

    //ignore some annoying log of MongoDB
    LoggerContext loggerContext = (LoggerContext)LoggerFactory.getILoggerFactory();
    loggerContext.getLogger("org.mongodb.driver").setLevel(Level.ERROR);
    //instantiate a MongoClient object without any parameters to connect to a MongoDB instance 
    //running on localhost on port 27017
    this.mongoClient = new MongoClient("localhost" , 27017);
    //create or get database mydb
    this.mongoDatabase = mongoClient.getDatabase("mydb");
    System.out.println("Connect to database successfully");
    //create or get players collection
    this.playersCollection = mongoDatabase.getCollection("players");
    System.out.println("Choose players collection successfully");
    //create or get games collection
    this.gamesCollection = mongoDatabase.getCollection("games");
    System.out.println("Choose games collection successfully");
    this.serializer = new JSONSerializer();
  }

  /**
   * All steps of the server side program
   */
  public void run() throws IOException{
    recoverPlayers();  
    recoverGames();  
    this.acceptPlayers(this.hostSocket);
    this.hostSocket.close();
  }

  /**
   * @return the list of available games for a player to join
   * should exclude the games that the player is already in
   */
  private List<Game> getAvailableGames(String playerName) {
    List<Game> res = new ArrayList<>();
    for (Game g : this.games) {
      if (!g.isGameFull() && g.IsPlayerExist(playerName).equals(false) && g.isComplete==false) {
        res.add(g);
      }
    }
    return res;
  }

  /**
   * @param playerName is the name of the player
   * @return the list of games that the player is in
   */
  private List<Game> getPlayerGame(String playerName) {
    List<Game> res = new ArrayList<>();
    for (Game g : this.games) {
      if (g.IsPlayerExist(playerName).equals(true)) {
        res.add(g);
      }
    }
    return res;
  }

  /**
   * this function send all open games and the gamesthat the player participated to the player
   *
   * @param player
   * @param playerName
   */
  public void sendGameList(ServerPlayer player, JsonNode rootNode) {
    player.sendMessage(allGameList(rootNode.path("name").textValue()));
  }

  /**
   * @param playerName is the player's name
   */
  public String allGameList(String playerName) {
    List<GameInfo> allOpen = new ArrayList<>();
    for (Game g : this.getAvailableGames(playerName)) {
      allOpen.add(new GameInfo(g.getGameID(), g.getAllPlayers()));
    }
    List<GameInfo> allJoined = new ArrayList<>();
    for (Game g : this.getPlayerGame(playerName)) {
        if(g.isComplete==false){
          allJoined.add(new GameInfo(g.getGameID(), g.getAllPlayers()));
        }   
    }
    String res = null;
    try {
      res = new JSONSerializer().getOm().writeValueAsString(allOpen) + "\n" + new JSONSerializer().getOm().writeValueAsString(allJoined);
    } catch (JsonProcessingException ignored) {
    }
    return res;
  }


  /**
   * start a new game for a user
   *
   * @param player is the player needs to login
   * @throws IOException if R/W exception
   */
  public Game startNewGame(ServerPlayer player, JsonNode rootNode) {
    int gameID = games.size();
    Game newGame = new Game(Integer.parseInt(rootNode.path("gameSize").textValue()), gameID);
    player.setCurrentGameID(gameID);
    games.add(newGame);
    // a new game should always add a player successfully
    // new game should assert newGame.addPlayer(player) == null;
    newGame.addPlayer(player);
    insertGamesCollection(newGame);
    return newGame;
  }

  /**
   * let the player join into an existing game
   *
   * @param player is the player needs to login
   * @throws IOException if R/W exception
   */
  public Game joinExistingGame(ServerPlayer player, JsonNode rootNode){
    // wait util the user give a valid game number
    int gameID = Integer.parseInt(rootNode.path("gameID").textValue());
    while (true) {
      String tryAddPlayerErrorMsg = games.get(gameID).addPlayer(player);
      if (tryAddPlayerErrorMsg == null) {
        player.setCurrentGameID(gameID);
        player.sendMessage(Constant.SUCCESS_NUMBER_CHOOSED);
        return games.get(gameID);
      } else {
        // in multi-thread env,
        // it's possible to have another user fill in the selected game before current user
        // not figure out a good way to test it tho
        player.sendMessage(tryAddPlayerErrorMsg);
      }
    }
  }

  /**
   * join into the game and if the game has enough players, run it
   * @param player is the player that choose join game
   * @param rootNode
   * @throws IOException
   */
  public void joinAndRun(ServerPlayer player, JsonNode rootNode){
    Game g = this.joinExistingGame(player, rootNode);
    updateGamesCollection(g);
    if (g.isGameFull()) {
      Thread t = new Thread(() -> {
        try {
          g.runGame(2, 6, gamesCollection,false);
        } catch (Exception e) {
          System.out.println("Exception catched when running the game!" + e.getMessage());
        }
      });
      t.start();
    }
  }

  /**
   * This function will let the player reconnect to the game
   *
   * @param player
   * @param n is the JSON Node recv from server
   */
  public void rejoinGame(ServerPlayer player, JsonNode n) {
    Integer currentGameID = Integer.parseInt(n.path("gameID").textValue());
    if(games.get(currentGameID).checkWin().equals(true)){
      player.sendMessage(Constant.CANNOT_REJOINGAME);
      player.sendMessage(Constant.CANNOT_REJOINGAME_WIN);
      return;
    }
    if(games.get(currentGameID).checkLost(player).equals(true)){
      player.sendMessage(Constant.CANNOT_REJOINGAME);
      player.sendMessage(Constant.CANNOT_REJOINGAME_LOSE);
      return;
    }
    player.sendMessage(Constant.CAN_REJOINGAME);
    player.setCurrentGameID(currentGameID);
    //System.out.print(player.getName()+"  "+currentGameID);
  }


  /**
   * This function will create a server player if he/she doesn't exist in the server side
   * or return the player from the player list if he/she has already exist
   * need to update the inputstream and outputstream
   *
   * @param playerName   is the name of the player
   * @param in           is the player's inputstream
   * @param out          is the player's outputstream
   * @param clientSocket is the player's socket
   * @return the unique serverplayer
   */
  public synchronized ServerPlayer createOrUpdatePlayer(String playerName, BufferedReader in, PrintWriter out, Socket clientSocket) {
    ServerPlayer player = null;
    if (!players.containsKey(playerName)) {
      player = new ServerPlayer(in, out, clientSocket);
      players.put(playerName, player);
      player.setName(playerName);
      insertPlayersCollection(player);
    } else {
      player = players.get(playerName);
      //update the player's inputstream and outputstream
      player.setInOut(in, out);
      player.setSocket(clientSocket);
    }
    return player;
  }

  public synchronized void insertPlayersCollection(ServerPlayer player){
    Document document = new Document("playerName", player.getName());
    playersCollection.insertOne(document);
  }

  public synchronized void insertGamesCollection(Game g){
    String s = serializer.serialize(g);
    Document document = new Document("gameID", g.getGameID()).append("description", s);
    gamesCollection.insertOne(document);
  }

  public synchronized void updateGamesCollection(Game g){
    String s = serializer.serialize(g);
    BasicDBObject newDocument = new BasicDBObject();
    newDocument.put("description", s); 
    BasicDBObject updateObject = new BasicDBObject();
    updateObject.put("$set", newDocument); 
    gamesCollection.updateOne(Filters.eq("gameID", g.getGameID()), updateObject);
  }

  public void recoverPlayers(){
    //recover players
    FindIterable<Document> findIterable = playersCollection.find();  
    MongoCursor<Document> mongoCursor = findIterable.iterator();  
    while(mongoCursor.hasNext()){
      ServerPlayer sp = new ServerPlayer(null,null,null);
      sp.setName((String)mongoCursor.next().get("playerName"));
      sp.setCurrentGameID(-1);
      players.put(sp.getName(), sp);
    }
  }

  public ArrayList<ServerPlayer> reinitializePlayers(ArrayList<ServerPlayer> list){
    ArrayList<ServerPlayer> res = new ArrayList<>();
    for(ServerPlayer sp:list){
      res.add(players.get(sp.getName()));
    }
    return res;
  }

  public void recoverGames(){
    //recover games
    FindIterable<Document> findIterable1 = gamesCollection.find();  
    MongoCursor<Document> mongoCursor1= findIterable1.iterator();  
    while(mongoCursor1.hasNext()){
      String gameString = (String)mongoCursor1.next().get("description");
      Game g = (Game)serializer.deserialize(gameString, Game.class);
      ArrayList<ServerPlayer> reinitializePlayers = reinitializePlayers(g.players);
      ArrayList<ServerPlayer> reinitializeStillIn = reinitializePlayers(g.stillInPlayers);
      ArrayList<ServerPlayer> reinitializeStillWatch = reinitializePlayers(g.stillWatchPlayers);
      g.resetPlayers(reinitializePlayers, reinitializeStillIn, reinitializeStillWatch);
      games.add(g);
      if(g.isGameFull() && !g.isComplete){
        Boolean isPlaceComplete = !(g.getMap().getAllTerritories().get(0).getNumSoldiersInArmy()==-1);
        Thread t = new Thread(() -> {
          try {
            g.runGame(2, 6, gamesCollection, isPlaceComplete);
          } catch (Exception e) {e.printStackTrace();}
        });
        t.start();
      }
    }    
  }

    

  /**
   * continuously accept connections and initialize players the player will be
   * asked whet he/she want to start a new game or join a game
   *
   * @param ss is the server socket for accepting connection
   */
  public void acceptPlayers(ServerSocket ss) {   
    while (!Thread.currentThread().isInterrupted()) {
      try {
        // accept a new connection and create a new player based on that
        Socket clientSocket = ss.accept();
        PrintWriter out = new PrintWriter(clientSocket.getOutputStream(), true);
        BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));
        ObjectMapper mapper = new ObjectMapper();
        JsonNode rootNode = mapper.readTree(in.readLine());//use readTree when not knowing the exact type of object
        String actionType = rootNode.path("type").textValue();
        String playerName = rootNode.path("name").textValue();
        ServerPlayer player = createOrUpdatePlayer(playerName, in, out, clientSocket);
        System.out.println(playerName+"  "+actionType);
        threadPool.execute(() -> {
          if (actionHandlerMap.containsKey(actionType)) {
              actionHandlerMap.get(actionType).apply(player, rootNode);        
        }
      });
      } catch (Exception e) {
        this.output.println(e.getMessage());
      }
    }
  }

  /**
   * The main function to run
   *
   * @param args is command line args which is [] for this program
   */
  public static void main(String[] args) throws IOException{
    App app = new App(new ServerSocket(4444), System.out);
    app.run();
  }

}
