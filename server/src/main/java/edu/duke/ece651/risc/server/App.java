/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package edu.duke.ece651.risc.server;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintStream;
import java.io.PrintWriter;
import java.net.ServerSocket;
import java.net.Socket;
import java.util.*;
import java.util.function.BiConsumer;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;

import edu.duke.ece651.risc.shared.*;
import edu.duke.ece651.risc.shared.game.GameInfo;


public class App {
  private final ArrayList<Game> games;
  private final HostSocket hostSocket;
  private final PrintStream output;
  private final JSONSerializer js;
  private Set<String> playerNames;
  private Map<String, ServerPlayer> players;

  /**
   * the constructor of App build the socket based on the port number initialize
   * the games list
   */
  public App(HostSocket s, PrintStream out) {
    games = new ArrayList<>();
    this.output = out;
    this.hostSocket = s;
    this.js = new JSONSerializer();
    this.playerNames = new HashSet<>();
    this.players = new HashMap<>();
  }

  /**
   * All steps of the server side program
   */
  public void run() {
    this.acceptPlayers(this.hostSocket.getSocket());
    this.hostSocket.closeSocket();
  }

  /**
   * @return the list of available games for a player ro join
   */
  private List<Game> getAvailableGames() {
    List<Game> res = new ArrayList<>();
    for (Game g : this.games) {
      if (!g.isGameFull()) {
        res.add(g);
      }
    }
    return res;
  }

  /**
   * @param playerName is the name of the player
   * @return the list of games that the player is in
   */
  private List<Game> getPlayerGame(String playerName) {
    List<Game> res = new ArrayList<>();
    for (Game g : this.games) {
      if (g.getPlayerByName(playerName) != null) {
        res.add(g);
      }
    }
    return res;
  }

  /**
   * this function send all open games and the gamesthat the player participated to the player
   *
   * @param player
   * @param playerName
   */
  public void sendGameList(ServerPlayer player, String playerName) {
    player.sendMessage(allGameList(playerName));
  }

  /**
   * start a new game for a user
   *
   * @param player is the player needs to login
   * @throws IOException if R/W exception
   */
  public void startNewGame(ServerPlayer player, Integer gameSize) throws IOException {
    int gameID = games.size();
    Game newGame = new Game(gameSize, gameID);
    player.setCurrentGameID(gameID);
    this.games.add(newGame);
    // a new game should always add a player successfully
    // new game should assert newGame.addPlayer(player) == null;
    newGame.addPlayer(player);
    newGame.runGame();
  }

  /**
   * let the player join into an existing game
   *
   * @param player is the player needs to login
   * @throws IOException if R/W exception
   */
  public void joinExistingGame(ServerPlayer player, Integer gameID) throws IOException {
    // wait util the user give a valid game number
    while (true) {
      String tryAddPlayerErrorMsg = games.get(gameID).addPlayer(player);
      if (tryAddPlayerErrorMsg == null) {
        player.setCurrentGameID(gameID);
        player.sendMessage(Constant.SUCCESS_NUMBER_CHOOSED);
        games.get(gameID).runGame();
        return;
      } else {
        // in multi-thread env,
        // it's possible to have another user fill in the selected game before current user
        // not figure out a good way to test it tho
        player.sendMessage(tryAddPlayerErrorMsg);
      }
    }
  }

  /**
   * This function will let the player reconnect to the game
   *
   * @param player
   * @param gameID
   */
  public void rejoinGame(ServerPlayer player, Integer gameID) {
    player.setCurrentGameID(gameID);
  }

  /**
   * @param playerName is the player's name
   */
  public String allGameList(String playerName) {
    List<GameInfo> allOpen = new ArrayList<>();
    for (Game g : this.getAvailableGames()) {
      allOpen.add(new GameInfo(g.getGameID(), g.getAllPlayers()));
    }
    List<GameInfo> allJoined = new ArrayList<>();
    for (Game g : this.getPlayerGame(playerName)) {
      allJoined.add(new GameInfo(g.getGameID(), g.getAllPlayers()));
    }
    String res = null;
    try {
      res = new JSONSerializer().getOm().writeValueAsString(allOpen) + "\n" + new JSONSerializer().getOm().writeValueAsString(allJoined);
    } catch (JsonProcessingException ignored) {
    }
    return res;
  }

  /**
   * This function will create a server player if he/she doesn't exist in the server side
   * or return the player from the player list if he/she has already exist
   * need to update the inputstream and outputstream
   *
   * @param playerName   is the name of the player
   * @param in           is the player's inputstream
   * @param out          is the player's outputstream
   * @param clientSocket is the player's socket
   * @return the unique serverplayer
   */
  private ServerPlayer createOrUpdatePlayer(String playerName, BufferedReader in, PrintWriter out, Socket clientSocket) {
    ServerPlayer player = null;
    if (!playerNames.contains(playerName)) {
      player = new ServerPlayer(in, out, clientSocket);
      player.setName(playerName);
    } else {
      player = players.get(playerName);
      //update the player's inputstream and outputstream
      player.setInOut(in, out);
    }
    return player;
  }


  /**
   * continuously accept connections and initialize players the player will be
   * asked whether he/she want to start a new game or join a game
   *
   * @param ss is the server socket for accepting connection
   */
  public void acceptPlayers(ServerSocket ss) {
    while (!Thread.currentThread().isInterrupted()) {
      try {
        // accept a new connection and create a new player based on that
        Socket clientSocket = ss.accept();
        PrintWriter out = new PrintWriter(clientSocket.getOutputStream(), true);
        BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));
        ObjectMapper mapper = new ObjectMapper();
        JsonNode rootNode = mapper.readTree(in.readLine());//use readTree when not knowing the exact type of object
        String actionType = rootNode.path("type").textValue();
        String playerName = rootNode.path("name").textValue();
        ServerPlayer player = createOrUpdatePlayer(playerName, in, out, clientSocket);
        if (actionType.equals("getGameList")) {
          sendGameList(player, playerName);
        } else if (actionType.equals("start")) {
          startNewGame(player, Integer.parseInt(rootNode.path("gameSize").textValue()));
        } else if (actionType.equals("join")) {
          joinExistingGame(player, Integer.parseInt(rootNode.path("gameID").textValue()));
        } else if (actionType.equals("rejoin")) {
          rejoinGame(player, Integer.parseInt(rootNode.path("gameID").textValue()));
        }
      } catch (IOException e) {
        this.output.println("Exception caught when listening for a connection");
        this.output.println(e.getMessage());
      }
    }
  }

  /**
   * The main function to run
   *
   * @param args is command line args which is [] for this program
   */
  public static void main(String[] args) {
    App app = new App(new HostSocket(4444), System.out);
    app.run();
  }

}
