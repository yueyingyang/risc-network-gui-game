/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package edu.duke.ece651.risc.client;

import edu.duke.ece651.risc.shared.ActionEntry;
import edu.duke.ece651.risc.shared.ClientPlayer;
import edu.duke.ece651.risc.shared.Constant;
import edu.duke.ece651.risc.shared.GameMap;

import java.io.*;
import java.net.Socket;
import java.util.Properties;

public class App {


  private final Socket socket;
  private final ClientPlayer player;

  public App(Socket s, BufferedReader userIn, PrintStream userOut) throws IOException {
    this.socket = s;
    player = new ClientPlayer(new BufferedReader(new InputStreamReader(s.getInputStream())),
            new PrintWriter(s.getOutputStream(), true), userIn, userOut);
  }

  public void loginGame() throws IOException {
    player.loginGame();
    player.display("Please wait for the game to start!");
  }

  public void endGame() throws IOException {
    player.closeIOStream();
    socket.close();
  }

  public void run() throws IOException {
    // login game: join an existed game / start a new game
    this.loginGame();
    this.placementPhase();
    this.attackPhase();
    this.endGame();
  }

  public void attackPhase() throws IOException {
    String mapOrGameOver = player.recvMessage();
    while (true) {
      player.playOneTurn(mapOrGameOver);
      player.display("Please wait for combat resolution...");
      // 1. recv combat result
      player.displayCombatRes();

      // 2. turnRes:
      String turnRes = player.recvMessage();
      // 2.1 Loser: Constant.LOSE_GAME
      if (turnRes.equals(Constant.LOSE_GAME)) {
        handleLosers(turnRes);
        return;
        // 2.2 Other players: Constant.CONTINUE_PLAYING
      } else {
        mapOrGameOver = getMapOrGameOver();
        if (mapOrGameOver == null) return;
      }
    }
  }

  private String getMapOrGameOver() throws IOException {
    String mapOrGameOver;
    // 2.2.1 mapOrGameOver = map, next turn starts
    mapOrGameOver = player.recvMessage();
    if (mapOrGameOver.equals(Constant.GAME_OVER)) {
      // 2.2.2 mapOrGameOver = GAME_OVER: prepare for next step
      player.display(Constant.GAME_OVER);
      // display winner
      player.display(player.recvMessage());
      return null;
    }
    return mapOrGameOver;
  }

  private void handleLosers(String turnRes) throws IOException {
    // 2.1 Loser: Constant.LOSE_GAME
    player.display(turnRes);
    String continueOrGameOver = player.recvMessage();
    if (continueOrGameOver.equals(Constant.CONTINUE_PLAYING)) {
      // 2.1.1 Lost but game still go on: can choose watch or disconnect
      player.watchGame("You can either \n" +
              "E Exit this game\n" +
              "C Continue to watch game\n");
    } else {
      // 2.1.2 Lost and game ends: continueOrGameOver = GAME OVER, winner
      player.display(continueOrGameOver);
      player.display(player.recvMessage());
    }
  }

  public void placementPhase() throws IOException {
    player.placementPhase();
  }

  public static void main(String[] args) throws IOException {
    // load a properties file
    InputStream propFileInputStream = App.class.getClassLoader().getResourceAsStream("config.properties");
    Properties prop = new Properties();
    prop.load(propFileInputStream);

    // init socket
    String hostName = prop.getProperty("server.hostname");
    int portNumber = Integer.parseInt(prop.getProperty("server.port"));
    Socket s = new Socket(hostName, portNumber);
    BufferedReader userIn = new BufferedReader(new InputStreamReader(System.in));
    App app = new App(s, userIn, System.out);
    app.run();
  }
}
